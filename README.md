# Baekjoon_Bronze
백준 브론즈 문제

[문제 오답]
15829.cpp 해시문제 (overflow 관련)
	==> (a * b) % M == ( (a % M) * (b % M) ) % M

1212.cpp 문자열을 입력받아 8진수에서 2진수로 변환하여 출력
	==> for문에 strlen()을 넣으면 반복할 때마다 O(N)이 호출되어 전체적으로 O(N^2)

10989.cpp N번(1 ≤ N ≤ 10,000,000) 정수형(1 <= number <= 10,000)이 주어질 때 이를 오름차순 정렬
	==> 입력받는 number를 long int num[N] 배열에 저장하게 되면 메모리가 초과된다.
	==> 메모이제이션(Memoization)
	==> 그러니 값들을 직접 저장하는 것이 아닌 int num[10,000] 배열을 선언하여
	==> 입력받은 number-1 인덱스의 값을 +1 시킨다.
	==> 출력할 때는 num 배열의 index+1값을 num[index] 값만큼 반복하여 출력한다.
	==> 나오지 않았다면 해당 num[index] 값은 0이니(0으로 초기화함), 출력되지 않아 걱정하지 않아도 된다.

11653.cpp 정수 N을 소인수분해하여 오름차순으로 출력
	==> for (i = 2; i < N_half; i++) => O(N) 수준이다.
	==> 불필요한 배열 계산과 소수 여부 판단 => for문 추가로 O(N^2)가 되버림
	==> 이 문제에서는 O(N)까지 혼자 줄여봤지만 시간 초과,, -> N_half보다 작아야 함.
	==> 정수 N을 a * b로 표현한다면 a, b의 동시 최저값은 루트 N이다.
	==> 근데 소수의 곱으로 표현한다면 이는 필히 루트 N보다 작은 값일 것이다.
	==> 그래서 for (i = 2; i * i <= N; i++) 까지 계산한다. O(루트 N)은 통과!

2810.cpp 영화관에서 컵을 컵홀더에 놓을 수 있는 최대 사람의 수를 출력
	==> 컵홀더 수가 아닌 최대 사람의 수를 출력한다. (문제를 유심히 보자!)

1373.cpp 2진수를 8진수로 출력
	==> char *new_str; char temp[] = "00"; new_str = strcat(temp, str);
	==> strcat함수에서 temp의 크기가 충분하지 않으면 정상 작동하지 않는다.
	==> 따라서 char new_str[SIZE+N]; new_str[0] = '\0'; strcat(new_str, str);
	==> 충분한 크기를 잡는다!
